apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "dojima-chain.fullname" . }}-scripts
data:
  password.sh: |
    #!/bin/bash
    NAME=$1
    echo "namespace :$NAME"

    touch /root/password.txt
    echo $SIGNER_PASSWD >> /root/password.txt
    echo "successfully created password file"

  check-narada.sh: |
    #!/bin/bash

    echo "Checking for narada to start"
    until curl -s "{{.Values.h4s.narada }}/ping" &>/dev/null; do
    echo "Waiting for narada to be available($1)"
    sleep 1
    done

  copy-keystore.sh: |
    #!/bin/bash
    ls -lasrt /root
    mkdir -p /root/.dojimachain/data/keystore
    cp /root/.hermesnode/UTC* /root/.dojimachain/data/keystore/
    ls -lasrt /root/.dojimachain/data/keystore/

  display-address.sh: |
    #!/bin/bash --help
    hermesnode
    #GETH=$(hermesnode eth-ks $CHAIN_HOME_FOLDER $SIGNER_NAME $SIGNER_PASSWD)
    #echo $GETH

  external-ip.sh: |
    #!/bin/bash
    # ./external-ip.sh <host_network> <service_name> <config_map>
    #
    # Script to extract external ip from a service:
    # If host network returns public ip of the node
    # If LoadBalancer returns external IP either directly or from hostname
    # If ClusterIP return service IP
    # If NodePort returns node IP

    apk add bind-tools

    HOST_NETWORK=$1
    SERVICE=$2
    CONFIGMAP=$3

    if [ "$HOST_NETWORK" = "true" ]; then
      external_ip=$(curl -s http://whatismyip.akamai.com)
    else
      type=$(kubectl get svc "$SERVICE" -o jsonpath='{.spec.type}')
      external_ip=""

      if [ "$type" = "ClusterIP" ]; then
        external_ip=$(kubectl get svc "$SERVICE" -o jsonpath='{.spec.clusterIP}')
      elif [ "$type" = "NodePort" ]; then
        external_ip=$(kubectl get nodes --selector=kubernetes.io/role!=master -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
      elif [ "$type" = "LoadBalancer" ]; then
        # Hack TODO remove when this is fixed here https://github.com/kubernetes/kubernetes/issues/82595
        kubectl annotate svc "$SERVICE" service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled=false --overwrite
        sleep 5
        kubectl annotate svc "$SERVICE" service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled=true --overwrite

        while [ -z "$external_ip" ]; do
          echo "Waiting for load balancer external endpoint..."
          external_ip=$(kubectl get svc "$SERVICE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$external_ip" ]; then
            hostname=$(kubectl get svc "$SERVICE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            [ -n "$hostname" ] && external_ip=$(dig +short "$hostname" | sort | head -1)
          fi
          [ -z "$external_ip" ] && sleep 10
        done
      fi
    fi

    kubectl create configmap "$CONFIGMAP" --from-literal=externalIP="$external_ip" --dry-run=client -o yaml | kubectl apply -f -


  probe.sh: |
    #!/bin/sh

    FILE=/root/.probe_last_height
    SYNCING=$(geth attach --exec eth.syncing http://localhost:{{ .Values.service.port.http }}) || exit 1
    HEIGHT=$(geth attach --exec eth.blockNumber http://localhost:{{ .Values.service.port.http }}) ||  exit 1
    echo "query height $HEIGHT"

    # first time we are syncing from scratch
    if [ "$HEIGHT" = "0" ]; then
      exit 0
    fi

    if [ ! -f "$FILE" ]; then
      echo "$HEIGHT" >$FILE
      echo "exit: 1 - Not getting new blocks"
      exit 1
    fi

    OLD=$(cat $FILE)
    echo "old $OLD"
    echo "$HEIGHT" >$FILE
    if [ "$OLD" = "$HEIGHT" ]; then
      echo "exit: 2 - Not getting new blocks"
      exit 1
    fi
    exit 0



